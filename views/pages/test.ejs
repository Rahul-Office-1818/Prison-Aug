<script>
  fetch("/api/cpulogs")
    .then((response) => response.json())
    .then((data) => {
      const logsTableBody = document.getElementById("logs-table-body");
      logsTableBody.innerHTML = ""; // Clear the table body before populating new data

      // Function to convert "days+hh:mm" format to total minutes in "hh:mm"
      function convertDuration(duration) {
        const match = duration.match(/(\d+)\+(\d{2}):(\d{2})/); // Match "1+08:26"
        if (match) {
          const days = parseInt(match[1]);
          const hours = parseInt(match[2]);
          const minutes = parseInt(match[3]);
          return `${days} D, ${hours} H, ${minutes} M`;
        } else {
          const match = duration.match(/(\d{2}):(\d{2})/); // Match "1+08:26"
          const hours = parseInt(match[1]);
          const minutes = parseInt(match[2]);
          return `${hours} H, ${minutes} M`; // Return the same if it doesn't match the "days+hh:mm" format
        }
      }

      data.payload.forEach((log, index) => {
        // Extract data using regex
        const timingMatch = log.timing.match(
          /- (\d{2}:\d{2}) \(([\d\+:\d{2}]+)\)/ // Match time like "18:08" and total_running_time
        );
        const reasonMatch = log.reason.match(
          /screen (\w{3} \w{3} \d{2}) (\d{2}:\d{2}) - (\d{2}:\d{2}) \(([\d\+:\d{2}]+)\)/ // Match the new reason format "screen Tue Nov 12 14:26 - 14:26 (00:00)"
        );

        let end_time = "";
        let total_running_time = "";
        let date = "";
        let start_time = "";
        let reason = "";

        // Handle "still running" case
        if (
          log.reason.includes("still logged in") ||
          log.timing.includes("still running")
        ) {
          // Extract start time and date for "still running"
          const stillRunningMatch = log.reason.match(
            /screen (.*) (\d{2}:\d{2}) still logged in/
          );
          if (stillRunningMatch) {
            date = stillRunningMatch[1]; // Extract date (e.g., Mon Apr 7)
            start_time = stillRunningMatch[2]; // Extract start time (e.g., 10:08)
          }
          end_time = "still running"; // For "still running" entries
          total_running_time = "still running"; // For "still running" entries
        } else if (timingMatch && reasonMatch) {
          // If it's not "still running", extract data as usual
          end_time = timingMatch[1]; // Extracted end_time
          total_running_time = convertDuration(timingMatch[2]); // Convert "1+08:26" or "00:15" etc.
          date = reasonMatch[1]; // Extracted date
          start_time = reasonMatch[2]; // Extracted start_time
          reason = reasonMatch[3]; // Extracted reason

          console.log("end_time:", end_time);
          console.log("total_running_time:", total_running_time);
          console.log("date:", date);
          console.log("start_time:", start_time);
          console.log("reason:", reason);
        }

        // Create a new table row and populate it with data
        const row = document.createElement("tr");
        row.classList.add(
          "text-center",
          "text-xl",
          "divide-x",
          "divide-gray-200"
        );

        // Populate the row with data
        row.innerHTML = `
                  <td scope="col" class="py-2">${index + 1}</td>
                  <td scope="col" class="py-2">${log.timing}, ${log.reason}</td>
                  <td scope="col" class="py-2">${start_time}</td>
                  <td scope="col" class="py-2">${end_time}</td>
                  <td scope="col" class="py-2">${date}</td>
                  <td scope="col" class="py-2">${total_running_time}</td>
                  <td scope="col" class="py-2">${reason}</td>
                `;

        // Append the row to the table body
        logsTableBody.appendChild(row);
      });
    })
    .catch((error) => console.error(error));
</script>
