<%- include('../partial/header'); %>

<div class="filter-div w-11/12 m-auto mt-2">
  <!-- <button type="button" id="logs-download" onclick="downloadTableAsExcel('logs-table')"> -->
    <button type="button" id="logs-download" onclick="download_toggle()">
    <div class="flex justify-center items-center gap-3 px-2">
      <p>Download</p>
      <img
        class="h-8 w-auto invert py-1"
        src="./assets/icon/download.png"
        alt="reload"
        srcset=""
      />
    </div>
    
  </button>
</div>
<div id="selectOption" class="disable-bg" onclick="download_toggle();">
  <div class="downlaod_choice">
      <div class="content">
          <div class="divimg">
              <button id="excel_button" onclick='downloadTableAsExcel("RADAR History","table_data",)'>
                  <i class="fa dicon">&#xf1c3;</i>
              </button>

              <button id="pdf_button" onclick='downloadTableAsPDF("RADAR History","table_data",10);'>
                  <i class="fa dicon">&#xf1c1;</i>
              </button>
              <!-- <div id="cr" onclick="download_toggle();" class="fa" style="cursor: pointer;">&#xf00d;</div> -->
          </div>
      </div>
  </div>

</div>

<div class="w-full h-dvh" id="cpulogs">
  <div class="cpulogs m-auto mt-6 overflow-auto">
    <table
      id="logs-table"
      class="w-full text-white border-slate-500 divide-y divide-gray-300 text-xl"
    >
      <thead class="sticky top-0 bg-black">
        <tr class="divide-gray-200">
          <th scope="col" class="py-2 text-yellow-50">S.no</th>
          <!-- <th scope="col" class="py-2 text-yellow-50">Date/Time</th> -->
          <th scope="col" class="py-2 text-yellow-50">Start Time</th>
          <th scope="col" class="py-2 text-yellow-50">Start Date</th>
          <th scope="col" class="py-2 text-yellow-50">End Time</th>
          <th scope="col" class="py-2 text-yellow-50">End Date</th>
          <th scope="col" class="py-2 text-yellow-50">Total Time</th>
          <th scope="col" class="py-2 text-yellow-50">Reason</th>
        </tr>
      </thead>
      <tbody id="logs-table-body" class="divide-y "></tbody>
    </table>
  </div>
</div>

<!--  - 13:13 (2+03:01), screen Thu Sep 19 10:12 - 10:12 (00:00)
        - 11:31 (12+22:17), screen Sat Sep 21 13:13 - down (12+22:17)
        - 10:38 (00:41), screen Wed Nov 20 09:56 - down (00:41) -->
<script>
  fetch("/api/cpulogs")
    .then((response) => response.json())
    .then((data) => {
      const logsTableBody = document.getElementById("logs-table-body");
      logsTableBody.innerHTML = ""; // Clear the table body before populating new data

      // Function to convert "days+hh:mm" format to total minutes in "hh:mm"
      function convertDuration(duration) {
        const match = duration.match(/(\d+)\+(\d{2}):(\d{2})/); // Match "1+08:26"
        if (match) {
          const days = parseInt(match[1]);
          const hours = parseInt(match[2]);
          const minutes = parseInt(match[3]);
          return `${days} D, ${hours} H, ${minutes} M`;
        } else {
          const match = duration.match(/(\d{2}):(\d{2})/); // Match "1+08:26"
          const hours = parseInt(match[1]);
          const minutes = parseInt(match[2]);
          return `${hours} H, ${minutes} M`; // Return the same if it doesn't match the "days+hh:mm" format
        }
      }

      data.payload.forEach((log, index) => {
        // Extract data using regex for the timing format
        const timingMatch = log.timing.match(
          /- (\d{2}:\d{2}) \(([\d\+:\d{2}]+)\)/ // Match time like "18:08" and total_running_time
        );

        // Regex to match the 3 types of reason formats
        const reasonMatch1 = log.reason.match(
          /screen (.*) (\d{2}:\d{2}) - (down|crash) \(([\d\+:\d{2}]+)\)/ // Match "down" or "crash"
        );
        const reasonMatch2 = log.reason.match(
          /screen (.*) (\d{2}:\d{2}) - (\d{2}:\d{2}) \(([\d\+:\d{2}]+)\)/ // Match same start and end time
        );

        let end_time = "";
        let total_running_time = "";
        let date = "";  
        let start_time = "";
        let reason = "";

        // Handle "still running" case
        if (
          log.reason.includes("still logged in") ||
          log.timing.includes("still running")
        ) {
          // Extract start time and date for "still running"
          const stillRunningMatch = log.reason.match(
            /screen (.*) (\d{2}:\d{2}) still logged in/
          );
          if (stillRunningMatch) {
            date = stillRunningMatch[1]; // Extract date (e.g., Mon Apr 7)
            start_time = stillRunningMatch[2]; // Extract start time (e.g., 10:08)
          }
          end_time = "still running"; // For "still running" entries
          total_running_time = "still running"; // For "still running" entries
        } else if (timingMatch && reasonMatch1) {
          // If it's the first type of reason (down/crash)
          end_time = timingMatch[1]; // Extracted end_time
          total_running_time = convertDuration(timingMatch[2]); // Convert "1+08:26" or "00:15" etc.
          date = reasonMatch1[1]; // Extracted date
          start_time = reasonMatch1[2]; // Extracted start_time
          reason = reasonMatch1[3]; // Extracted reason ("down" or "crash")
        } else if (timingMatch && reasonMatch2) {
          // If it's the second type of reason (same start and end time)
          end_time = reasonMatch2[2]; // Extracted same end time
          total_running_time = convertDuration(timingMatch[2]); // Convert "00:00" time
          date = reasonMatch2[1]; // Extracted date
          start_time = reasonMatch2[2]; // Extracted start time (same as end time)
          reason = " Not Sure"; // Indicating the times are the same
        }

        // Calculate end date
        let end_date = date; // Default in case calculation fails

        if (start_time && date && total_running_time !== "still running") {
          const [dayName, month, day] = date.split(" ");
          const currentYear = new Date().getFullYear(); // You can hardcode the year if needed
          const startDateTime = new Date(`${month} ${day} ${currentYear} ${start_time}`);

          const timeParts = total_running_time.match(/(?:(\d+) D, )?(\d+) H, (\d+) M/);
          if (timeParts) {
            const days = parseInt(timeParts[1]) || 0;
            const hours = parseInt(timeParts[2]);
            const minutes = parseInt(timeParts[3]);

            // Add time to the start date
            startDateTime.setMinutes(startDateTime.getMinutes() + minutes);
            startDateTime.setHours(startDateTime.getHours() + hours);
            startDateTime.setDate(startDateTime.getDate() + days);

            // Format the new end date
            const endDayName = startDateTime.toLocaleString('en-US', { weekday: 'short' });
            const endMonth = startDateTime.toLocaleString('en-US', { month: 'short' });
            const endDay = String(startDateTime.getDate()).padStart(2, '0');
            end_date = `${endDayName} ${endMonth} ${endDay}`;
          }
        }

        // Create a new table row and populate it with data
        const row = document.createElement("tr");
        row.classList.add("text-center", "text-xl", "divide-gray-200");

        // Populate the row with data
        // <td scope="col" class="py-2">${log.timing}, ${log.reason}</td>
        row.innerHTML = `
                  <td scope="col" class="py-2">${index + 1}</td>
                  <td scope="col" class="py-2">${start_time}</td>
                  <td scope="col" class="py-2">${date}</td>
                  <td scope="col" class="py-2">${end_time}</td>
                  <td scope="col" class="py-2">${end_date}</td>
                  <td scope="col" class="py-2">${total_running_time}</td>
                  <td scope="col" class="py-2">${reason}</td>
                `;

        // Append the row to the table body
        logsTableBody.appendChild(row);
      });
    })
    .catch((error) => console.error(error));
</script>
<script>
  function download_toggle() {
      $("#selectOption").toggle();
  }

</script>

<%- include('../partial/footer'); %>
